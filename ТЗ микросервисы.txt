Техническое задание  
Практическое изучение микросервисов и способов взаимодействия между ними  

1. Цель  
Изучение и практическое применение принципов микросервисной архитектуры, включая:  
- Разработку отдельных микросервисов на Java.  
- Организацию взаимодействия между сервисами.  
- Обеспечение отказоустойчивости, масштабируемости и мониторинга.  

2. Область применения  
Создание демонстрационного проекта, включающего несколько микросервисов, взаимодействующих между собой.  

3. Технические требования  
3.1. Стек технологий  
- Язык программирования: Java 17+  
- Фреймворки: Spring Boot 3.x, Spring Cloud  
- Базы данных: PostgreSQL / MongoDB (на выбор для разных сервисов)  
- Брокер сообщений: Apache Kafka / RabbitMQ  
- API-шлюз: Spring Cloud Gateway  
- Сервис обнаружения: Eureka / Consul  
- Распределённая трассировка: Zipkin / Jaeger  
- Логирование: ELK Stack (Elasticsearch, Logstash, Kibana) / Grafana Loki  
- Мониторинг: Prometheus + Grafana  
- Контейнеризация: Docker + Docker Compose / Kubernetes (опционально)  

.2. Функциональные требования  
3.2.1. Микросервисы  
1. Сервис пользователей (User Service)  
   - Регистрация, аутентификация (JWT/OAuth2).  
   - Хранение данных пользователей (PostgreSQL).  
   - API: REST + gRPC (опционально).  

2. Сервис заказов (Order Service)  
   - Создание, изменение, отмена заказов.  
   - Взаимодействие с Inventory Service для проверки наличия товаров.  
   - Хранение данных (MongoDB).  

3. Сервис инвентаря (Inventory Service)  
   - Управление товарами (наличие, резервирование).  
   - Синхронизация с Order Service через события (Kafka/RabbitMQ).  

4. API Gateway  
   - Маршрутизация запросов.  
   - Аутентификация/авторизация.  
   - Логирование запросов.  

5. Конфигурационный сервис (Config Service)  
   - Централизованное управление конфигурациями (Spring Cloud Config).  

6. Сервис нотификаций (Notification Service)  
   - Отправка уведомлений (email, websocket) на основе событий.  

3.2.2. Взаимодействие между сервисами  
- Синхронное: REST (OpenAPI/Swagger), gRPC.  
- Асинхронное: Kafka/RabbitMQ (Event-Driven Architecture).  
- Отказоустойчивость: Resilience4j (Circuit Breaker, Retry).  
- Балансировка нагрузки: Spring Cloud LoadBalancer.  

3.2.3. Мониторинг и логирование  
- Метрики: Spring Boot Actuator + Prometheus + Grafana.  
- Логи: Централизованное логирование (ELK/Loki).  
- Трассировка: Распределённая трассировка запросов (Zipkin/Jaeger).  

4. Этапы выполнения  
1. Проектирование архитектуры (схема взаимодействия сервисов).  
2. Настройка инфраструктуры (Docker, базы данных, брокер сообщений).  
3. Разработка микросервисов (по одному, с постепенной интеграцией).  
4. Настройка API Gateway, Service Discovery, Config Service.  
5. Реализация взаимодействия (REST, gRPC, Kafka).  
6. Добавление отказоустойчивости (Resilience4j, Hystrix).  
7. Настройка мониторинга и логирования.  
8. Тестирование (интеграционные, нагрузочные тесты).  
9. Документирование (Swagger, README, диаграммы).  

5. Критерии приемки  
- Все сервисы запускаются в Docker-контейнерах.  
- Реализовано взаимодействие (REST + Kafka).  
- Настроен API Gateway и Service Discovery.  
- Работает мониторинг (Grafana) и трассировка (Zipkin).  
- Написаны интеграционные тесты.  

6. Дополнительные задания (опционально)  
- Развертывание в Kubernetes (Helm, Kustomize).  
- Реализация Saga Pattern для распределённых транзакций.  
- Использование GraphQL (Apollo Federation).  

7. Результат  
- Исходный код на GitHub/GitLab.  
- Docker-compose файл для запуска всей системы.  
- Документация (API-спецификации, диаграммы).